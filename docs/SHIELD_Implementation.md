# SHIELD Principle Implementation in ImpowerSurvey

This document explains how the ImpowerSurvey system architecture implements the SHIELD principle (Separate Human Identities Entirely from Linked Data).

## Core Architecture

ImpowerSurvey employs a double-blind architecture where **identities** and **data** are kept fundamentally separate through several technical mechanisms:

### 1. Database Separation

The `SurveyDbContext` maintains strict entity separation:

```csharp
// Identity side
public DbSet<User> Users { get; set; }

// Data side (no user identifiers)
public DbSet<Survey> Surveys { get; set; }
public DbSet<Question> Questions { get; set; }
public DbSet<Response> Responses { get; set; }

// Bridge mechanisms (using anonymized codes)
public DbSet<EntryCode> EntryCodes { get; set; }
public DbSet<CompletionCode> CompletionCodes { get; set; }
public DbSet<ParticipationRecord> ParticipationRecords { get; set; }
```

The `Response` entity stores survey answers without any link to user identity:

```csharp
public class Response
{
    public int Id { get; set; }
    public Guid SurveyId { get; set; }
    public int QuestionId { get; set; }
    public string Answer { get; set; }
    public Question Question { get; set; }
    public Survey Survey { get; set; }
    public double Discrepancy { get; set; }
    public QuestionTypes QuestionType { get; set; }
    // No User ID or other identifying information
}
```

### 2. Double-Blind Code System

The system uses anonymous codes as the bridge mechanism:

#### Entry Codes
- Generated when surveys are created or as needed
- Provide access to surveys without revealing who is taking them
- Generated by `SurveyService.GenerateCodes(count)` during survey kickoff
- Validated by `SurveyCodeService.ValidateEntryCodeAsync(code)`

#### Completion Codes
- Issued upon survey completion
- Verify participation without linking to specific response content
- Retrieved using `SurveyCodeService.GetCompletionCodeAsync(surveyId)`

This creates the double-blind system where:
1. User identity → Entry Code → Survey Access
2. Survey Completion → Completion Code → Participation Record

### 3. Participation Tracking

`ParticipationRecord` tracks participation without linking identities to responses:

```csharp
public class ParticipationRecord
{
    public Guid Id { get; set; }
    public Guid CompletionCodeId { get; set; }
    public string UsedBy { get; set; } // Generic identifier, typically an email
    public DateTime UsedAt { get; set; }
    public CompletionCode CompletionCode { get; set; }
}
```

This allows verifying that a user completed a survey without revealing which specific answers they provided.

## Service Implementation

### SurveyService

The `SurveyService` enforces SHIELD through:

1. **Anonymous Response Submission**
   ```csharp
   public async Task<DataServiceResult<string>> SubmitSurveyAsync(Guid surveyId, string entryCode, List<Response> responses)
   {
       // NOTE: We intentionally don't log the user or specific response details here
       // due to SHIELD compliance requirements
       
       // Validate the survey exists and is in running state
       var survey = await dbContext.Surveys.FirstOrDefaultAsync(s => s.Id == surveyId);
       if (survey == null)
           return ServiceResult.Failure<string>(Constants.Survey.NotFound);
           
       if (survey.State != SurveyStates.Running)
           return ServiceResult.Failure<string>(Constants.Survey.NoSubmissions);

       // Burn entry code without linking to specific responses
       var burnResult = await surveyCodeService.BurnEntryCodeAsync(entryCode);
       if (!burnResult)
           return ServiceResult.Failure<string>(Constants.EntryCodes.InvalidOrUsed);
       
       // Queue responses for delayed submission - further anonymization
       delayedSubmissionService.QueueResponses(responses);

       // Generate completion code (the only "receipt" of participation)
       var codeResult = await surveyCodeService.GetCompletionCodeAsync(surveyId);
       
       return ServiceResult.Success(codeResult.Data, string.Empty);
   }
   ```

2. **Delayed Submission**
   - The `DelayedSubmissionService` further separates submission timing from identity
   - Responses can be queued and submitted at random intervals

### UserService

The `UserService` handles identity management separately from survey data:

```csharp
public class UserService
{
    // User identity operations
    public async Task<User> GetUserAsync(string username) { /* ... */ }
    public async Task<User> GetUserAsync(Guid userId) { /* ... */ }
    public async Task<IEnumerable<User>> GetUsersByRoles(params Roles[] roles) { /* ... */ }
    public async Task<DataServiceResult<string>> CreateUserAsync(string username, string displayName, string email, Roles role) { /* ... */ }
    public async Task<bool> UpdateTimeZone(Guid userId, string timeZone) { /* ... */ }
    
    // Note: Has no access to survey response data - complete separation
}
```

## UI Implementation

### SHIELD Visualization

The UI visually reinforces the separation principle:

1. **ShieldControl.razor** - Provides visual indication of SHIELD protection
2. **ShieldPopup.razor** - Explains the SHIELD separation to users

These components include messaging:
- "Your identity is completely separate from any survey responses"
- "Even administrators cannot link your identity to specific responses"
- "Participation is tracked separately from response content"

## Maintaining SHIELD Compliance

To maintain SHIELD compliance in future development:

1. **Never** add direct identifiers to the `Response` entity
2. **Always** use the code system for bridging identity and participation
3. **Keep** the service layers separate - identity services should not directly access response data
4. **Ensure** UI components continue to reinforce the separation visually
5. **Verify** that no database queries can join identity tables with response tables

By adhering to these principles, ImpowerSurvey ensures that human identities remain completely separated from the survey data they provide.